# 类似微信聊天系统 - 演进式架构规划（5轮迭代）

## 原始需求
- **系统类型**: 类似微信的聊天系统
- **核心功能**: 用户注册登录、发送消息、接收消息、单聊、群聊
- **规模假设**: 日活用户1000万，峰值QPS 10万，消息量每天10亿条
- **稳定性要求**: 99.9%可用性，消息不丢失

---

## 第1轮：实现核心业务功能

### 1. Pick & Solve (当前回合)
- **当前处理问题**: 实现核心业务功能
- **决策**: 设计最简单的单体架构，包含核心业务组件
- **执行**: 更新架构描述

### 2. Current_Architecture (第1轮后)

```
┌─────────────────────────────────────┐
│      Web Server (单体应用)          │
│  ┌──────────────────────────────┐  │
│  │  User Service                 │  │
│  │  - 注册/登录                  │  │
│  │  - 用户信息管理               │  │
│  └──────────────────────────────┘  │
│  ┌──────────────────────────────┐  │
│  │  Message Service              │  │
│  │  - 发送消息                   │  │
│  │  - 接收消息                   │  │
│  │  - 单聊/群聊                  │  │
│  └──────────────────────────────┘  │
│  ┌──────────────────────────────┐  │
│  │  Session Service              │  │
│  │  - 会话管理                   │  │
│  │  - 好友关系                   │  │
│  └──────────────────────────────┘  │
└─────────────────────────────────────┘
              │
              ▼
    ┌──────────────────┐
    │   MySQL Database │
    │  - users         │
    │  - messages      │
    │  - sessions      │
    └──────────────────┘
```

**架构说明**:
- 单体应用，所有服务部署在一台服务器
- 使用 MySQL 存储用户、消息、会话数据
- HTTP 接口提供服务

### 3. Audit (红队攻击)

**攻击点**:
1. ❌ **单点故障**: 服务器宕机，整个系统不可用 → 添加 ["解决单点故障"]
2. ❌ **性能瓶颈**: 10万QPS会打爆单机 → 添加 ["解决性能瓶颈"]
3. ❌ **数据库瓶颈**: MySQL单机无法承受10万QPS → 添加 ["解决数据库性能瓶颈"]
4. ❌ **消息实时性**: HTTP轮询延迟高，用户体验差 → 添加 ["实现实时消息推送"]
5. ❌ **数据丢失风险**: 消息只存数据库，无备份 → 添加 ["实现消息持久化与备份"]

### 4. Issue_Backlog (第1轮后)
```
[
  "解决单点故障",
  "解决性能瓶颈", 
  "解决数据库性能瓶颈",
  "实现实时消息推送",
  "实现消息持久化与备份"
]
```

---

## 第2轮：解决单点故障

### 1. Pick & Solve (当前回合)
- **当前处理问题**: 解决单点故障
- **决策**: 引入负载均衡 + 多实例部署，数据库主从复制
- **执行**: 更新架构描述

### 2. Current_Architecture (第2轮后)

```
                    ┌──────────────┐
                    │  Load Balancer│
                    └──────┬───────┘
                           │
        ┌──────────────────┼──────────────────┐
        │                  │                  │
   ┌────▼────┐       ┌────▼────┐       ┌────▼────┐
   │ App Server│      │ App Server│      │ App Server│
   │ Instance 1│      │ Instance 2│      │ Instance 3│
   │           │      │           │      │           │
   │ User Svc  │      │ User Svc  │      │ User Svc  │
   │ Message   │      │ Message   │      │ Message   │
   │ Session   │      │ Session   │      │ Session   │
   └────┬──────┘      └────┬──────┘      └────┬──────┘
        │                  │                  │
        └──────────────────┼──────────────────┘
                           │
                    ┌──────▼──────┐
                    │   MySQL     │
                    │   Master    │
                    └──────┬──────┘
                           │
                    ┌──────▼──────┐
                    │   MySQL     │
                    │   Slave     │
                    │  (Read Only)│
                    └─────────────┘
```

**架构说明**:
- 负载均衡器分发请求到多个应用实例
- 应用服务无状态，可水平扩展
- MySQL 主从复制，主库写，从库读

### 3. Audit (红队攻击)

**攻击点**:
1. ❌ **负载均衡器单点**: LB挂了全挂 → 添加 ["解决负载均衡器高可用"]
2. ❌ **数据库主库单点**: 主库挂了无法写入 → 添加 ["解决数据库主库高可用"]
3. ⚠️ **性能瓶颈**: 虽然解决了单点，但10万QPS仍可能打爆 → 已存在 ["解决性能瓶颈"]
4. ❌ **会话状态**: 无状态服务无法知道用户在线状态 → 添加 ["实现用户在线状态管理"]
5. ❌ **消息顺序**: 多实例可能导致消息乱序 → 添加 ["保证消息顺序性"]

### 4. Issue_Backlog (第2轮后)
```
[
  "解决性能瓶颈",
  "解决数据库性能瓶颈",
  "实现实时消息推送",
  "实现消息持久化与备份",
  "解决负载均衡器高可用",
  "解决数据库主库高可用",
  "实现用户在线状态管理",
  "保证消息顺序性"
]
```

---

## 第3轮：解决性能瓶颈

### 1. Pick & Solve (当前回合)
- **当前处理问题**: 解决性能瓶颈
- **决策**: 引入 Redis 缓存热点数据，消息队列异步处理，读写分离优化数据库
- **执行**: 更新架构描述

### 2. Current_Architecture (第3轮后)

```
                    ┌──────────────┐
                    │  Load Balancer│
                    └──────┬───────┘
                           │
        ┌──────────────────┼──────────────────┐
        │                  │                  │
   ┌────▼────┐       ┌────▼────┐       ┌────▼────┐
   │ App Server│      │ App Server│      │ App Server│
   │ Instance 1│      │ Instance 2│      │ Instance 3│
   │           │      │           │      │           │
   │ User Svc  │      │ User Svc  │      │ User Svc  │
   │ Message   │      │ Message   │      │ Message   │
   │ Session   │      │ Session   │      │ Session   │
   └────┬──────┘      └────┬──────┘      └────┬──────┘
        │                  │                  │
        └──────────────────┼──────────────────┘
                           │
        ┌──────────────────┼──────────────────┐
        │                  │                  │
   ┌────▼────┐       ┌────▼────┐       ┌────▼────┐
   │  Redis   │      │  Redis   │      │ Message │
   │ Cluster  │      │ Cluster  │      │ Queue   │
   │ (Cache)  │      │ (Session)│      │ (Kafka) │
   └────┬─────┘      └────┬─────┘      └────┬────┘
        │                  │                  │
        └──────────────────┼──────────────────┘
                           │
                    ┌──────▼──────┐
                    │   MySQL     │
                    │   Master    │
                    └──────┬──────┘
                           │
        ┌──────────────────┼──────────────────┐
        │                  │                  │
   ┌────▼────┐       ┌────▼────┐       ┌────▼────┐
   │ MySQL   │      │ MySQL   │      │ MySQL   │
   │ Slave 1 │      │ Slave 2 │      │ Slave 3 │
   └─────────┘      └─────────┘      └─────────┘
```

**架构说明**:
- Redis Cluster 缓存用户信息、会话信息
- Redis Cluster 存储用户在线状态
- Kafka 消息队列异步处理消息发送，削峰填谷
- MySQL 一主多从，读请求分散到多个从库

### 3. Audit (红队攻击)

**攻击点**:
1. ⚠️ **数据库性能**: 虽然有了从库，但写入仍可能成为瓶颈 → 已存在 ["解决数据库性能瓶颈"]
2. ❌ **消息队列单点**: Kafka集群需要保证高可用 → 添加 ["保证消息队列高可用"]
3. ❌ **缓存穿透**: 缓存失效可能导致数据库被打爆 → 添加 ["防止缓存穿透/击穿"]
4. ❌ **消息丢失**: 消息在队列中可能丢失 → 添加 ["保证消息可靠性"]
5. ⚠️ **实时性**: 虽然有了队列，但实时推送仍未解决 → 已存在 ["实现实时消息推送"]

### 4. Issue_Backlog (第3轮后)
```
[
  "解决数据库性能瓶颈",
  "实现实时消息推送",
  "实现消息持久化与备份",
  "解决负载均衡器高可用",
  "解决数据库主库高可用",
  "实现用户在线状态管理",
  "保证消息顺序性",
  "保证消息队列高可用",
  "防止缓存穿透/击穿",
  "保证消息可靠性"
]
```

---

## 第4轮：实现实时消息推送

### 1. Pick & Solve (当前回合)
- **当前处理问题**: 实现实时消息推送
- **决策**: 引入 WebSocket 长连接服务，独立的消息推送服务，使用连接管理器
- **执行**: 更新架构描述

### 2. Current_Architecture (第4轮后)

```
                    ┌──────────────┐
                    │  Load Balancer│
                    └──────┬───────┘
                           │
        ┌──────────────────┼──────────────────┐
        │                  │                  │
   ┌────▼────┐       ┌────▼────┐       ┌────▼────┐
   │ App Server│      │ App Server│      │ App Server│
   │ Instance 1│      │ Instance 2│      │ Instance 3│
   │           │      │           │      │           │
   │ User Svc  │      │ User Svc  │      │ User Svc  │
   │ Message   │      │ Message   │      │ Message   │
   │ Session   │      │ Session   │      │ Session   │
   └────┬──────┘      └────┬──────┘      └────┬──────┘
        │                  │                  │
        └──────────────────┼──────────────────┘
                           │
        ┌──────────────────┼──────────────────┐
        │                  │                  │
   ┌────▼────┐       ┌────▼────┐       ┌────▼────┐
   │ WebSocket│      │ WebSocket│      │ WebSocket│
   │ Gateway 1│      │ Gateway 2│      │ Gateway 3│
   │          │      │          │      │          │
   │ Connection│     │ Connection│     │ Connection│
   │ Manager   │     │ Manager   │     │ Manager   │
   └────┬──────┘      └────┬──────┘      └────┬──────┘
        │                  │                  │
        └──────────────────┼──────────────────┘
                           │
                    ┌──────▼──────┐
                    │ Push Service│
                    │ (消息推送)  │
                    └──────┬──────┘
                           │
        ┌──────────────────┼──────────────────┐
        │                  │                  │
   ┌────▼────┐       ┌────▼────┐       ┌────▼────┐
   │  Redis   │      │  Redis   │      │ Message │
   │ Cluster  │      │ Cluster  │      │ Queue   │
   │ (Cache)  │      │ (Session)│      │ (Kafka) │
   └────┬─────┘      └────┬─────┘      └────┬────┘
        │                  │                  │
        └──────────────────┼──────────────────┘
                           │
                    ┌──────▼──────┐
                    │   MySQL     │
                    │   Master    │
                    └──────┬──────┘
                           │
        ┌──────────────────┼──────────────────┐
        │                  │                  │
   ┌────▼────┐       ┌────▼────┐       ┌────▼────┐
   │ MySQL   │      │ MySQL   │      │ MySQL   │
   │ Slave 1 │      │ Slave 2 │      │ Slave 3 │
   └─────────┘      └─────────┘      └─────────┘
```

**架构说明**:
- WebSocket Gateway 集群处理长连接
- Connection Manager 管理用户连接映射（存储在Redis）
- Push Service 从消息队列消费，根据用户连接信息推送消息
- 用户上线时建立WebSocket连接，下线时断开

### 3. Audit (红队攻击)

**攻击点**:
1. ❌ **连接路由问题**: 用户连接在Gateway1，但消息可能被推送到Gateway2 → 添加 ["实现连接路由一致性"]
2. ❌ **跨机房问题**: 用户在不同机房，连接和推送可能跨机房延迟高 → 添加 ["优化跨机房通信"]
3. ❌ **推送失败处理**: 用户离线时消息推送失败，需要存储 → 添加 ["实现离线消息存储"]
4. ❌ **Gateway单点**: Gateway集群需要保证高可用和负载均衡 → 添加 ["保证WebSocket Gateway高可用"]
5. ⚠️ **数据库性能**: 写入压力仍然存在 → 已存在 ["解决数据库性能瓶颈"]

### 4. Issue_Backlog (第4轮后)
```
[
  "解决数据库性能瓶颈",
  "实现消息持久化与备份",
  "解决负载均衡器高可用",
  "解决数据库主库高可用",
  "实现用户在线状态管理",
  "保证消息顺序性",
  "保证消息队列高可用",
  "防止缓存穿透/击穿",
  "保证消息可靠性",
  "实现连接路由一致性",
  "优化跨机房通信",
  "实现离线消息存储",
  "保证WebSocket Gateway高可用"
]
```

---

## 第5轮：解决数据库性能瓶颈

### 1. Pick & Solve (当前回合)
- **当前处理问题**: 解决数据库性能瓶颈
- **决策**: 数据库分库分表，引入时序数据库存储消息，冷热数据分离
- **执行**: 更新架构描述

### 2. Current_Architecture (第5轮后)

```
                    ┌──────────────┐
                    │  Load Balancer│
                    └──────┬───────┘
                           │
        ┌──────────────────┼──────────────────┐
        │                  │                  │
   ┌────▼────┐       ┌────▼────┐       ┌────▼────┐
   │ App Server│      │ App Server│      │ App Server│
   │ Instance 1│      │ Instance 2│      │ Instance 3│
   │           │      │           │      │           │
   │ User Svc  │      │ User Svc  │      │ User Svc  │
   │ Message   │      │ Message   │      │ Message   │
   │ Session   │      │ Session   │      │ Session   │
   └────┬──────┘      └────┬──────┘      └────┬──────┘
        │                  │                  │
        └──────────────────┼──────────────────┘
                           │
        ┌──────────────────┼──────────────────┐
        │                  │                  │
   ┌────▼────┐       ┌────▼────┐       ┌────▼────┐
   │ WebSocket│      │ WebSocket│      │ WebSocket│
   │ Gateway 1│      │ Gateway 2│      │ Gateway 3│
   └────┬──────┘      └────┬──────┘      └────┬──────┘
        │                  │                  │
        └──────────────────┼──────────────────┘
                           │
                    ┌──────▼──────┐
                    │ Push Service│
                    └──────┬──────┘
                           │
        ┌──────────────────┼──────────────────┐
        │                  │                  │
   ┌────▼────┐       ┌────▼────┐       ┌────▼────┐
   │  Redis   │      │  Redis   │      │ Message │
   │ Cluster  │      │ Cluster  │      │ Queue   │
   │ (Cache)  │      │ (Session)│      │ (Kafka) │
   └────┬─────┘      └────┬─────┘      └────┬────┘
        │                  │                  │
        └──────────────────┼──────────────────┘
                           │
        ┌──────────────────┼──────────────────┐
        │                  │                  │
   ┌────▼────┐       ┌────▼────┐       ┌────▼────┐
   │ MySQL   │      │ MySQL   │      │ MySQL   │
   │ Shard 1 │      │ Shard 2 │      │ Shard N │
   │ (User)  │      │ (User)  │      │ (User)  │
   └────┬────┘      └────┬────┘      └────┬────┘
        │                  │                  │
        └──────────────────┼──────────────────┘
                           │
                    ┌──────▼──────┐
                    │  TiDB/      │
                    │  TimescaleDB│
                    │  (Messages) │
                    └──────┬──────┘
                           │
                    ┌──────▼──────┐
                    │  Object     │
                    │  Storage    │
                    │  (Cold Msg) │
                    └─────────────┘
```

**架构说明**:
- MySQL 按用户ID分库分表，分散写入压力
- 使用 TiDB 或 TimescaleDB 存储消息（时序数据库，适合消息场景）
- 冷数据（3个月以上）迁移到对象存储（S3/OSS）
- 热点消息数据保留在时序数据库，支持快速查询

### 3. Audit (红队攻击)

**攻击点**:
1. ❌ **分库分表路由**: 需要统一的路由层，避免业务代码耦合 → 添加 ["实现数据库路由中间件"]
2. ❌ **跨分片查询**: 群聊消息需要跨分片聚合，性能差 → 添加 ["优化跨分片查询性能"]
3. ❌ **数据一致性**: 分库分表后，事务一致性变复杂 → 添加 ["保证分布式事务一致性"]
4. ❌ **冷热数据迁移**: 需要自动化任务迁移冷数据 → 添加 ["实现冷热数据自动迁移"]
5. ⚠️ **其他问题**: 之前的问题仍需解决 → 继续迭代

### 4. Issue_Backlog (第5轮后)
```
[
  "实现消息持久化与备份",
  "解决负载均衡器高可用",
  "解决数据库主库高可用",
  "实现用户在线状态管理",
  "保证消息顺序性",
  "保证消息队列高可用",
  "防止缓存穿透/击穿",
  "保证消息可靠性",
  "实现连接路由一致性",
  "优化跨机房通信",
  "实现离线消息存储",
  "保证WebSocket Gateway高可用",
  "实现数据库路由中间件",
  "优化跨分片查询性能",
  "保证分布式事务一致性",
  "实现冷热数据自动迁移"
]
```

---

## 总结

经过5轮迭代，架构从简单的单体应用演进为：
- ✅ **高可用**: 多实例部署、主从复制
- ✅ **高性能**: 缓存、消息队列、分库分表
- ✅ **实时性**: WebSocket长连接、消息推送
- ✅ **可扩展**: 水平扩展、冷热分离

**架构演进路径**:
1. 单体应用 → 多实例 + 主从
2. 引入缓存和消息队列
3. 实时推送能力
4. 数据库分库分表

**剩余问题**: Backlog中还有16个问题待解决，可以继续迭代优化。

